const express = require('express');
const cors = require('cors');
const db = require('./database');
const crypto = require('crypto');

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

// --- UTILS ---
const generateId = () => Date.now().toString();

// --- AUTH ROUTES ---

// Login
app.post('/api/auth/login', (req, res) => {
    const { email, password } = req.body;
    
    db.get("SELECT * FROM users WHERE email = ?", [email], (err, user) => {
        if (err) return res.status(500).json({ error: err.message });
        if (!user) return res.status(404).json({ error: "User not found" });

        // NOTE: In a real production app, we would re-hash the input password and compare.
        // For this transition phase, we are sending the user object back so the frontend 
        // Verifier (which contains the specific hash logic) can double check, 
        // OR we can move the hash check here.
        // Let's return the user data needed for the frontend Verifier.js to do its "NIST" check.
        res.json(user); 
    });
});

// Register
app.post('/api/auth/register', (req, res) => {
    const { name, email, role, passwordHash, salt, bioEncoded } = req.body;
    const id = generateId();
    // Simulate key generation on server or accept from client? 
    // The client RA generates it in the current architecture.
    // We'll accept the one generated by the client for now to keep the RA logic intact.
    const encryptionKey = req.body.encryptionKey || "SERVER_GENERATED_KEY"; 

    const stmt = db.prepare("INSERT INTO users (id, name, email, role, passwordHash, salt, bioEncoded, encryptionKey) VALUES (?,?,?,?,?,?,?,?)");
    stmt.run(id, name, email, role, passwordHash, salt, bioEncoded, encryptionKey, function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ id, name, email, role });
    });
    stmt.finalize();
});

// Get All Users (for Chat Contacts)
app.get('/api/users', (req, res) => {
    db.all("SELECT id, name, email, role, encryptionKey FROM users", [], (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows);
    });
});

// --- MENTORSHIP ROUTES ---

app.get('/api/mentorships', (req, res) => {
    db.all("SELECT * FROM mentorships ORDER BY timestamp DESC", [], (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows);
    });
});

app.post('/api/mentorships', (req, res) => {
    const { studentId, studentName, topic } = req.body;
    const id = generateId();
    const status = 'Pending';
    const timestamp = new Date().toISOString();

    const stmt = db.prepare("INSERT INTO mentorships (id, studentId, studentName, topic, status, timestamp) VALUES (?,?,?,?,?,?)");
    stmt.run(id, studentId, studentName, topic, status, timestamp, function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ id, studentId, studentName, topic, status, timestamp });
    });
    stmt.finalize();
});

app.post('/api/mentorships/:id/approve', (req, res) => {
    const { id } = req.params;
    db.run("UPDATE mentorships SET status = 'Approved' WHERE id = ?", [id], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});

// --- REFERRAL ROUTES ---

app.get('/api/referrals', (req, res) => {
    db.all("SELECT * FROM referrals ORDER BY timestamp DESC", [], (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows);
    });
});

app.post('/api/referrals', (req, res) => {
    const { alumniId, alumniName, company, role, desc, hash } = req.body;
    const id = generateId();
    const timestamp = new Date().toISOString();

    const stmt = db.prepare("INSERT INTO referrals (id, alumniId, alumniName, company, role, desc, hash, timestamp) VALUES (?,?,?,?,?,?,?,?)");
    stmt.run(id, alumniId, alumniName, company, role, desc, hash, timestamp, function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ id, alumniId, alumniName, company, role, desc, hash, timestamp });
    });
    stmt.finalize();
});

// --- MESSAGE ROUTES ---

app.get('/api/messages', (req, res) => {
    db.all("SELECT * FROM messages ORDER BY timestamp ASC", [], (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows);
    });
});

app.post('/api/messages', (req, res) => {
    const { fromId, toId, encryptedContent, iv } = req.body;
    const id = generateId();
    const timestamp = new Date().toISOString();

    const stmt = db.prepare("INSERT INTO messages (id, fromId, toId, encryptedContent, iv, timestamp) VALUES (?,?,?,?,?,?)");
    stmt.run(id, fromId, toId, encryptedContent, iv, timestamp, function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ id, fromId, toId, encryptedContent, iv, timestamp });
    });
    stmt.finalize();
});

// --- LOGGING ROUTES ---
app.get('/api/logs', (req, res) => {
    db.all("SELECT * FROM logs ORDER BY timestamp DESC", [], (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows);
    });
});

app.post('/api/logs', (req, res) => {
    const { userId, action, details } = req.body;
    const timestamp = new Date().toISOString();

    const stmt = db.prepare("INSERT INTO logs (userId, action, details, timestamp) VALUES (?,?,?,?)");
    stmt.run(userId, action, details, timestamp, function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
    stmt.finalize();
});


app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
